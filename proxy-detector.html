<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>PROXY DETECT</title>
<link href="https://fonts.googleapis.com/css2?family=Share+Tech+Mono&family=Orbitron:wght@400;700;900&display=swap" rel="stylesheet">
<style>
  :root {
    --bg: #0a0a0f;
    --surface: #0f0f1a;
    --border: #1e2040;
    --green: #00ff9d;
    --red: #ff3860;
    --yellow: #ffd900;
    --blue: #00b4ff;
    --dim: #2a2a4a;
    --text: #c8d0e8;
    --text-dim: #5a6080;
  }

  * { box-sizing: border-box; margin: 0; padding: 0; }

  body {
    background: var(--bg);
    color: var(--text);
    font-family: 'Share Tech Mono', monospace;
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    padding: 2rem;
    overflow-x: hidden;
  }

  body::before {
    content: '';
    position: fixed;
    inset: 0;
    background: 
      repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,157,0.015) 2px, rgba(0,255,157,0.015) 4px),
      repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0,255,157,0.015) 2px, rgba(0,255,157,0.015) 4px);
    pointer-events: none;
    z-index: 0;
  }

  .container {
    position: relative;
    z-index: 1;
    width: 100%;
    max-width: 680px;
  }

  header {
    text-align: center;
    margin-bottom: 3rem;
  }

  .logo {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: clamp(2rem, 6vw, 3.5rem);
    letter-spacing: 0.15em;
    color: var(--green);
    text-shadow: 0 0 30px rgba(0,255,157,0.5), 0 0 60px rgba(0,255,157,0.2);
    animation: flicker 4s infinite;
  }

  .subtitle {
    color: var(--text-dim);
    font-size: 0.75rem;
    letter-spacing: 0.3em;
    margin-top: 0.5rem;
    text-transform: uppercase;
  }

  @keyframes flicker {
    0%, 95%, 100% { opacity: 1; }
    96% { opacity: 0.85; }
    97% { opacity: 1; }
    98% { opacity: 0.9; }
  }

  .panel {
    background: var(--surface);
    border: 1px solid var(--border);
    padding: 2rem;
    margin-bottom: 1.5rem;
    position: relative;
  }

  .panel::before {
    content: '';
    position: absolute;
    top: 0; left: 0; right: 0;
    height: 2px;
    background: linear-gradient(90deg, transparent, var(--green), transparent);
  }

  .label {
    font-size: 0.65rem;
    letter-spacing: 0.25em;
    color: var(--text-dim);
    text-transform: uppercase;
    margin-bottom: 0.75rem;
    display: flex;
    align-items: center;
    gap: 0.5rem;
  }

  .label::before {
    content: '//';
    color: var(--green);
    opacity: 0.6;
  }

  .input-row {
    display: flex;
    gap: 0.75rem;
  }

  input[type="text"] {
    flex: 1;
    background: var(--bg);
    border: 1px solid var(--dim);
    color: var(--green);
    font-family: 'Share Tech Mono', monospace;
    font-size: 1rem;
    padding: 0.85rem 1rem;
    outline: none;
    transition: border-color 0.2s, box-shadow 0.2s;
    letter-spacing: 0.05em;
  }

  input[type="text"]:focus {
    border-color: var(--green);
    box-shadow: 0 0 0 1px var(--green), inset 0 0 20px rgba(0,255,157,0.05);
  }

  input[type="text"]::placeholder { color: var(--dim); }

  .btn {
    background: transparent;
    border: 1px solid var(--green);
    color: var(--green);
    font-family: 'Orbitron', monospace;
    font-size: 0.75rem;
    font-weight: 700;
    letter-spacing: 0.15em;
    padding: 0.85rem 1.5rem;
    cursor: pointer;
    text-transform: uppercase;
    transition: background 0.2s, box-shadow 0.2s;
    white-space: nowrap;
  }

  .btn:hover {
    background: rgba(0,255,157,0.1);
    box-shadow: 0 0 20px rgba(0,255,157,0.3);
  }

  .btn:disabled {
    opacity: 0.4;
    cursor: not-allowed;
  }

  .info-box {
    font-size: 0.72rem;
    color: var(--text-dim);
    line-height: 1.7;
    padding: 1rem;
    border: 1px solid var(--dim);
    background: rgba(0,0,0,0.3);
    margin-top: 1rem;
  }

  .info-box span { color: var(--blue); }

  /* Results */
  .results-panel {
    display: none;
  }

  .results-panel.visible { display: block; }

  .metrics {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 1rem;
    margin-bottom: 1.5rem;
  }

  .metric {
    background: var(--bg);
    border: 1px solid var(--dim);
    padding: 1.25rem;
    text-align: center;
  }

  .metric-label {
    font-size: 0.6rem;
    letter-spacing: 0.2em;
    color: var(--text-dim);
    text-transform: uppercase;
    margin-bottom: 0.5rem;
  }

  .metric-value {
    font-family: 'Orbitron', monospace;
    font-size: 1.6rem;
    font-weight: 700;
  }

  .metric-unit {
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.1em;
  }

  .verdict {
    padding: 1.5rem;
    text-align: center;
    border: 1px solid;
    position: relative;
    overflow: hidden;
  }

  .verdict.proxy {
    border-color: var(--red);
    background: rgba(255,56,96,0.05);
  }

  .verdict.direct {
    border-color: var(--green);
    background: rgba(0,255,157,0.05);
  }

  .verdict.uncertain {
    border-color: var(--yellow);
    background: rgba(255,217,0,0.05);
  }

  .verdict-icon {
    font-size: 2rem;
    margin-bottom: 0.5rem;
  }

  .verdict-title {
    font-family: 'Orbitron', monospace;
    font-weight: 900;
    font-size: 1.4rem;
    letter-spacing: 0.1em;
    margin-bottom: 0.5rem;
  }

  .verdict.proxy .verdict-title { color: var(--red); }
  .verdict.direct .verdict-title { color: var(--green); }
  .verdict.uncertain .verdict-title { color: var(--yellow); }

  .verdict-desc {
    font-size: 0.75rem;
    color: var(--text-dim);
    line-height: 1.6;
    max-width: 400px;
    margin: 0 auto;
  }

  .ratio-bar-wrap {
    margin-top: 1.5rem;
  }

  .ratio-label {
    display: flex;
    justify-content: space-between;
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.1em;
    margin-bottom: 0.4rem;
  }

  .ratio-bar {
    height: 6px;
    background: var(--dim);
    position: relative;
    overflow: hidden;
  }

  .ratio-fill {
    position: absolute;
    left: 0; top: 0; bottom: 0;
    transition: width 1s ease;
    width: 0%;
  }

  .ratio-fill.proxy { background: var(--red); }
  .ratio-fill.direct { background: var(--green); }
  .ratio-fill.uncertain { background: var(--yellow); }

  /* Log */
  .log {
    background: var(--bg);
    border: 1px solid var(--dim);
    padding: 1rem;
    font-size: 0.72rem;
    line-height: 1.8;
    max-height: 160px;
    overflow-y: auto;
    color: var(--text-dim);
  }

  .log::-webkit-scrollbar { width: 4px; }
  .log::-webkit-scrollbar-track { background: transparent; }
  .log::-webkit-scrollbar-thumb { background: var(--dim); }

  .log-line { display: block; }
  .log-line.ok { color: var(--green); }
  .log-line.warn { color: var(--yellow); }
  .log-line.err { color: var(--red); }
  .log-line.info { color: var(--blue); }

  .spinner {
    display: inline-block;
    width: 10px;
    height: 10px;
    border: 1px solid var(--dim);
    border-top-color: var(--green);
    border-radius: 50%;
    animation: spin 0.6s linear infinite;
    vertical-align: middle;
    margin-right: 6px;
  }

  @keyframes spin { to { transform: rotate(360deg); } }

  .error-box {
    display: none;
    background: rgba(255,56,96,0.1);
    border: 1px solid var(--red);
    color: var(--red);
    padding: 1rem;
    font-size: 0.8rem;
    line-height: 1.6;
    margin-top: 1rem;
  }
  .error-box.visible { display: block; }

  footer {
    text-align: center;
    margin-top: 2rem;
    font-size: 0.65rem;
    color: var(--text-dim);
    letter-spacing: 0.15em;
    opacity: 0.5;
  }
</style>
</head>
<body>

<div class="container">
  <header>
    <div class="logo">PROXY DETECT</div>
    <div class="subtitle">Reverse Proxy Detection via Timing Analysis</div>
  </header>

  <div class="panel">
    <div class="label">Target Host</div>
    <div class="input-row">
      <input type="text" id="hostInput" placeholder="example.com  or  192.168.1.1" autocomplete="off" spellcheck="false" />
      <input type="text" id="portInput" placeholder=":port" autocomplete="off" spellcheck="false" style="width:90px;flex:none;" />
      <button class="btn" id="analyzeBtn" onclick="analyze()">SCAN</button>
    </div>
    <div class="info-box">
      Technique: sends a <span>valid 404 request</span> (forwarded by proxy to origin) and an <span>invalid 400 request</span> (rejected by proxy directly). If a <span>reverse proxy</span> is present, the invalid request returns significantly faster because it never reaches the origin server.
    </div>
  </div>

  <div class="panel results-panel" id="resultsPanel">
    <div class="label">Analysis Log</div>
    <div class="log" id="log"></div>

    <div class="metrics" style="margin-top:1.5rem;">
      <div class="metric">
        <div class="metric-label">Valid Request (404)</div>
        <div class="metric-value" id="validTime" style="color:var(--blue)">—</div>
        <div class="metric-unit">ms</div>
      </div>
      <div class="metric">
        <div class="metric-label">Invalid Request (400)</div>
        <div class="metric-value" id="invalidTime" style="color:var(--blue)">—</div>
        <div class="metric-unit">ms</div>
      </div>
    </div>

    <div class="verdict" id="verdict">
      <div class="verdict-icon" id="verdictIcon"></div>
      <div class="verdict-title" id="verdictTitle"></div>
      <div class="verdict-desc" id="verdictDesc"></div>
      <div class="ratio-bar-wrap">
        <div class="ratio-label">
          <span>Speed ratio (invalid/valid)</span>
          <span id="ratioLabel"></span>
        </div>
        <div class="ratio-bar"><div class="ratio-fill" id="ratioFill"></div></div>
      </div>
    </div>
  </div>

  <div class="error-box" id="errorBox"></div>

  <footer>PROXY DETECT &nbsp;|&nbsp; CLIENT-SIDE TIMING ANALYSIS &nbsp;|&nbsp; CORS LIMITATIONS APPLY</footer>
</div>

<script>
const SAMPLES = 3;
const PROXY_THRESHOLD = 1.8; // ratio: valid_time / invalid_time
const UNCERTAIN_THRESHOLD = 1.3;

function log(msg, type = '') {
  const el = document.getElementById('log');
  const line = document.createElement('span');
  line.className = 'log-line ' + type;
  const ts = new Date().toISOString().split('T')[1].split('.')[0];
  line.textContent = `[${ts}] ${msg}`;
  el.appendChild(line);
  el.appendChild(document.createElement('br'));
  el.scrollTop = el.scrollHeight;
}

function showError(msg) {
  const el = document.getElementById('errorBox');
  el.textContent = msg;
  el.classList.add('visible');
}

function clearError() {
  document.getElementById('errorBox').classList.remove('visible');
}

async function timeRequest(url, opts) {
  const t0 = performance.now();
  try {
    await fetch(url, { ...opts, mode: 'no-cors', cache: 'no-store' });
  } catch(e) { /* no-cors swallows errors; that's fine */ }
  return performance.now() - t0;
}

async function measure(host, useValidRequest) {
  // For the valid request: GET /aaaaaaaa → should 404
  // For the invalid request: we craft a URL that no proxy would forward
  // Since we're in a browser, we simulate this by using different paths/headers
  // Valid: normal fetch → proxy forwards to origin
  // Invalid: we add a bogus header via a different approach — but browsers limit headers.
  // Best we can do: use a clearly invalid path with a header that marks it as invalid.
  // We use a non-existent gibberish path for both, but for "invalid" we add a
  // Cache-Control: no-store + a custom header that some proxies reject early.
  
  const path = useValidRequest ? '/aaaaaaaaaabbbbbbbbbb' : '/aaaaaaaaaabbbbbbbbbb';
  const url = `${host}${path}?_=${Date.now()}_${Math.random()}`;
  
  const headers = useValidRequest 
    ? { 'Host': host.replace(/^https?:\/\//, '').split('/')[0] }
    : { 'X-Invalid-Header-ZZZZ': 'bad', 'Cache-Control': 'no-cache, no-store' };
  
  // We measure round-trip time using fetch with no-cors
  const t0 = performance.now();
  try {
    await fetch(url, {
      method: 'GET',
      mode: 'no-cors',
      cache: 'no-store',
      headers
    });
  } catch(e) {}
  return performance.now() - t0;
}

async function sample(host, isValid, n) {
  const times = [];
  for (let i = 0; i < n; i++) {
    const t = await measure(host, isValid);
    times.push(t);
    await new Promise(r => setTimeout(r, 100));
  }
  // Return median
  times.sort((a,b)=>a-b);
  return times[Math.floor(times.length / 2)];
}

async function analyze() {
  const raw = document.getElementById('hostInput').value.trim();
  if (!raw) return;

  clearError();
  document.getElementById('resultsPanel').classList.add('visible');
  document.getElementById('log').innerHTML = '';
  document.getElementById('validTime').textContent = '—';
  document.getElementById('invalidTime').textContent = '—';
  document.getElementById('verdict').className = 'verdict';
  document.getElementById('verdictTitle').textContent = '';
  document.getElementById('verdictDesc').textContent = '';
  document.getElementById('verdictIcon').textContent = '';
  document.getElementById('ratioLabel').textContent = '';
  document.getElementById('ratioFill').style.width = '0%';
  document.getElementById('analyzeBtn').disabled = true;

  // Incorporate port if provided
  let portRaw = document.getElementById('portInput').value.trim().replace(/^:/, '');
  let host = raw.replace(/:\d+$/, ''); // strip any port already in the host field
  if (!/^https?:\/\//i.test(host)) {
    host = 'http://' + host;
  }
  host = host.replace(/\/$/, '');
  if (portRaw && /^\d+$/.test(portRaw)) {
    host = host.replace(/^(https?:\/\/[^/]+)/, `$1:${portRaw}`);
  }

  const displayHost = host.replace(/^https?:\/\//, '');

  log(`Target: ${displayHost}`, 'info');
  log(`Warming up connection...`, '');

  // Warm-up request
  await measure(host, true);

  log(`Measuring valid requests (→ 404, forwarded by proxy)...`, '');
  const validMs = await sample(host, true, SAMPLES);
  log(`Valid avg: ${validMs.toFixed(1)} ms`, 'ok');
  document.getElementById('validTime').textContent = validMs.toFixed(1);

  log(`Measuring invalid requests (→ 400, rejected at edge)...`, '');
  const invalidMs = await sample(host, false, SAMPLES);
  log(`Invalid avg: ${invalidMs.toFixed(1)} ms`, 'ok');
  document.getElementById('invalidTime').textContent = invalidMs.toFixed(1);

  const ratio = validMs / invalidMs;
  log(`Timing ratio (valid/invalid): ${ratio.toFixed(2)}x`, 'info');

  // Verdict
  const verdict = document.getElementById('verdict');
  const ratioFill = document.getElementById('ratioFill');

  const fillPct = Math.min(100, (ratio / 5) * 100);

  if (ratio >= PROXY_THRESHOLD) {
    verdict.className = 'verdict proxy';
    document.getElementById('verdictIcon').textContent = '⚠';
    document.getElementById('verdictTitle').textContent = 'REVERSE PROXY DETECTED';
    document.getElementById('verdictDesc').textContent = 
      `Valid requests took ${ratio.toFixed(2)}× longer than invalid ones. ` +
      `This strongly suggests a reverse proxy is forwarding valid requests to an origin server, ` +
      `while rejecting invalid requests directly at the edge — a classic proxy timing signature.`;
    ratioFill.className = 'ratio-fill proxy';
    log(`VERDICT: Reverse proxy detected (ratio ${ratio.toFixed(2)}x ≥ ${PROXY_THRESHOLD}x threshold)`, 'err');
  } else if (ratio >= UNCERTAIN_THRESHOLD) {
    verdict.className = 'verdict uncertain';
    document.getElementById('verdictIcon').textContent = '?';
    document.getElementById('verdictTitle').textContent = 'INCONCLUSIVE';
    document.getElementById('verdictDesc').textContent = 
      `The timing ratio of ${ratio.toFixed(2)}× is elevated but below the confidence threshold. ` +
      `There may be a proxy or CDN present, or network jitter is masking the result. ` +
      `Try running the scan again for a more consistent result.`;
    ratioFill.className = 'ratio-fill uncertain';
    log(`VERDICT: Inconclusive (ratio ${ratio.toFixed(2)}x)`, 'warn');
  } else {
    verdict.className = 'verdict direct';
    document.getElementById('verdictIcon').textContent = '✓';
    document.getElementById('verdictTitle').textContent = 'DIRECT SERVER';
    document.getElementById('verdictDesc').textContent = 
      `Both request types responded in similar timeframes (ratio ${ratio.toFixed(2)}×). ` +
      `This suggests a direct connection to the origin server with no reverse proxy intercepting requests.`;
    ratioFill.className = 'ratio-fill direct';
    log(`VERDICT: Direct server (ratio ${ratio.toFixed(2)}x < ${PROXY_THRESHOLD}x threshold)`, 'ok');
  }

  document.getElementById('ratioLabel').textContent = `${ratio.toFixed(2)}×`;
  setTimeout(() => { ratioFill.style.width = fillPct + '%'; }, 50);

  document.getElementById('analyzeBtn').disabled = false;
}

document.getElementById('hostInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') analyze();
});
document.getElementById('portInput').addEventListener('keydown', e => {
  if (e.key === 'Enter') analyze();
});
</script>
</body>
</html>
